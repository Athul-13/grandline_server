import { inject, injectable } from 'tsyringe';
import { ICalculateRoutesUseCase } from '../../interface/quote/calculate_routes_use_case.interface';
import { CalculateRoutesRequest, RouteCalculationResponse } from '../../../dtos/quote.dto';
import { IQuoteRepository } from '../../../../domain/repositories/quote_repository.interface';
import { IRouteCalculationService, IRouteSegment } from '../../../../domain/services/route_calculation_service.interface';
import { QuoteItinerary } from '../../../../domain/entities/quote_itinerary.entity';
import { REPOSITORY_TOKENS, SERVICE_TOKENS } from '../../../di/tokens';
import { ERROR_MESSAGES, ERROR_CODES } from '../../../../shared/constants';
import { AppError } from '../../../../shared/utils/app_error.util';
import { logger } from '../../../../shared/logger';

/**
 * Use case for calculating routes for a quote
 * Handles route calculation using Mapbox service and updates quote with route data
 */
@injectable()
export class CalculateRoutesUseCase implements ICalculateRoutesUseCase {
  constructor(
    @inject(REPOSITORY_TOKENS.IQuoteRepository)
    private readonly quoteRepository: IQuoteRepository,
    @inject(SERVICE_TOKENS.IRouteCalculationService)
    private readonly routeCalculationService: IRouteCalculationService
  ) {}

  async execute(quoteId: string, request: CalculateRoutesRequest, userId: string): Promise<RouteCalculationResponse> {
    try {
      // Input validation
      if (!quoteId || typeof quoteId !== 'string' || quoteId.trim().length === 0) {
        throw new AppError(ERROR_MESSAGES.BAD_REQUEST, 'INVALID_QUOTE_ID', 400);
      }

      if (!userId || typeof userId !== 'string' || userId.trim().length === 0) {
        throw new AppError(ERROR_MESSAGES.BAD_REQUEST, 'INVALID_USER_ID', 400);
      }

      if (!request || !request.itinerary || !request.itinerary.outbound || request.itinerary.outbound.length === 0) {
        throw new AppError(ERROR_MESSAGES.BAD_REQUEST, 'INVALID_ITINERARY', 400);
      }

      logger.info(`Calculating routes for quote: ${quoteId} by user: ${userId}`);

      // Get quote and verify ownership
      const quote = await this.quoteRepository.findById(quoteId);

      if (!quote) {
        throw new AppError(ERROR_MESSAGES.QUOTE_NOT_FOUND, ERROR_CODES.QUOTE_NOT_FOUND, 404);
      }

      if (quote.userId !== userId) {
        throw new AppError(ERROR_MESSAGES.QUOTE_NOT_FOUND, ERROR_CODES.QUOTE_NOT_FOUND, 404);
      }

      // Convert DTO itinerary to QuoteItinerary entities
      const outboundItinerary: QuoteItinerary[] = request.itinerary.outbound.map((stop, index) => {
        if (!stop.arrivalTime) {
          throw new AppError(ERROR_MESSAGES.BAD_REQUEST, 'ARRIVAL_TIME_REQUIRED', 400);
        }
        return new QuoteItinerary(
          '', // itineraryId will be generated by repository
          quoteId,
          'outbound',
          index + 1,
          stop.locationName,
          stop.latitude,
          stop.longitude,
          new Date(stop.arrivalTime),
          stop.stopType,
          new Date(),
          new Date(),
          stop.departureTime ? new Date(stop.departureTime) : undefined,
          stop.isDriverStaying || false,
          stop.stayingDuration
        );
      });

      // Convert return itinerary if present
      let returnItinerary: QuoteItinerary[] | undefined;
      if (request.itinerary.return && request.itinerary.return.length > 0) {
        returnItinerary = request.itinerary.return.map((stop, index) => {
          if (!stop.arrivalTime) {
            throw new AppError(ERROR_MESSAGES.BAD_REQUEST, 'ARRIVAL_TIME_REQUIRED', 400);
          }
          return new QuoteItinerary(
            '', // itineraryId will be generated by repository
            quoteId,
            'return',
            index + 1,
            stop.locationName,
            stop.latitude,
            stop.longitude,
            new Date(stop.arrivalTime),
            stop.stopType,
            new Date(),
            new Date(),
            stop.departureTime ? new Date(stop.departureTime) : undefined,
            stop.isDriverStaying || false,
            stop.stayingDuration
          );
        });
      }

      // Calculate routes
      const routeResults = await this.routeCalculationService.calculateRoutes(
        outboundItinerary,
        returnItinerary
      );

      // Update quote with route data
      const routeData = {
        outbound: {
          totalDistance: routeResults.outbound.totalDistance,
          totalDuration: routeResults.outbound.totalDuration,
          routeGeometry: routeResults.outbound.routeGeometry,
        },
        return: routeResults.return
          ? {
              totalDistance: routeResults.return.totalDistance,
              totalDuration: routeResults.return.totalDuration,
              routeGeometry: routeResults.return.routeGeometry,
            }
          : undefined,
      };

      await this.quoteRepository.updateById(quoteId, {
        routeData,
      });

      // Map segments to response format
      const mapSegments = (segments: IRouteSegment[]) => {
        return segments.map((segment) => ({
          from: {
            latitude: segment.from.latitude,
            longitude: segment.from.longitude,
            locationName: segment.from.locationName,
          },
          to: {
            latitude: segment.to.latitude,
            longitude: segment.to.longitude,
            locationName: segment.to.locationName,
          },
          distance: segment.distance,
          duration: segment.duration,
          hasNightTravel: segment.hasNightTravel,
        }));
      };

      // Build response
      const response: RouteCalculationResponse = {
        outbound: {
          totalDistance: routeResults.outbound.totalDistance,
          totalDuration: routeResults.outbound.totalDuration,
          routeGeometry: routeResults.outbound.routeGeometry,
          segments: mapSegments(routeResults.outbound.segments),
        },
      };

      if (routeResults.return) {
        response.return = {
          totalDistance: routeResults.return.totalDistance,
          totalDuration: routeResults.return.totalDuration,
          routeGeometry: routeResults.return.routeGeometry,
          segments: mapSegments(routeResults.return.segments),
        };
      }

      logger.info(`Routes calculated successfully for quote: ${quoteId}`);
      return response;
    } catch (error) {
      logger.error(
        `Error calculating routes for quote ${quoteId}: ${error instanceof Error ? error.message : 'Unknown error'}`
      );

      if (error instanceof AppError) {
        throw error;
      }

      throw new AppError(
        ERROR_MESSAGES.ROUTE_CALCULATION_FAILED,
        ERROR_CODES.ROUTE_CALCULATION_ERROR,
        500
      );
    }
  }
}
